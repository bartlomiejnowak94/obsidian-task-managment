/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => main_default
});

// src/taskcollector-Plugin.ts
var import_obsidian4 = __toModule(require("obsidian"));

// src/taskcollector-TaskCollector.ts
var import_obsidian = __toModule(require("obsidian"));
var TaskCollector = class {
  constructor(app) {
    this.app = app;
    this.app = app;
    this.anyListItem = new RegExp(/^([\s>]*- )([^\\[].*)$/);
    this.anyTaskMark = new RegExp(/^([\s>]*- \[).(\] .*)$/);
    this.blockQuote = new RegExp(/^(\s*>[\s>]*)(.*)$/);
    this.blockRef = new RegExp(/^(.*?)( \^[A-Za-z0-9-]+)?$/);
    this.continuation = new RegExp(/^( {2,}|\t)/);
    this.stripTask = new RegExp(/^([\s>]*-) \[.\] (.*)$/);
  }
  updateSettings(settings) {
    this.settings = settings;
    let momentMatchString = null;
    if (settings.appendDateFormat) {
      const literals = [];
      const regex1 = RegExp("(\\[.*?\\]\\]?)", "g");
      let match;
      let i = 0;
      momentMatchString = settings.appendDateFormat;
      while ((match = regex1.exec(momentMatchString)) !== null) {
        momentMatchString = momentMatchString.replace(match[0], `%$${i}$%`);
        literals.push(match[0].substring(1, match[0].length - 1).replace(/\(/g, "\\(").replace(/\)/g, "\\)").replace(/\[/g, "\\[").replace(/\]/g, "\\]"));
        i++;
      }
      momentMatchString = momentMatchString.replace("YYYY", "\\d{4}").replace("YY", "\\d{2}").replace("DD", "\\d{2}").replace("D", "\\d{1,2}").replace("MMM", "[A-Za-z]{3}").replace("MM", "\\d{2}").replace("M", "\\d{1,2}").replace("HH", "\\d{2}").replace("H", "\\d{1,2}").replace("hh", "\\d{2}").replace("h", "\\d{1,2}").replace("mm", "\\d{2}").replace("m", "\\d{1,2}");
      if (literals.length > 0) {
        for (let i2 = 0; i2 < literals.length; i2++) {
          momentMatchString = momentMatchString.replace(`%$${i2}$%`, literals[i2]);
        }
      }
    }
    const completedTasks = (this.settings.onlyLowercaseX ? "x" : "xX") + (this.settings.supportCanceledTasks ? "-" : "");
    if (this.settings.incompleteTaskValues.indexOf(" ") < 0) {
      this.settings.incompleteTaskValues = " " + this.settings.incompleteTaskValues;
    }
    const rightClickTaskMenu = this.settings.rightClickComplete || this.settings.rightClickMark || this.settings.rightClickMove || this.settings.rightClickResetTask || this.settings.rightClickResetAll || this.settings.rightClickToggleAll;
    this.initSettings = {
      removeRegExp: this.tryCreateRemoveRegex(this.settings.removeExpression),
      resetRegExp: this.tryCreateResetRegex(momentMatchString),
      incompleteTaskRegExp: this.tryCreateIncompleteRegex(this.settings.incompleteTaskValues),
      rightClickTaskMenu,
      completedTasks,
      completedTaskRegExp: this.tryCreateCompleteRegex(completedTasks)
    };
    console.debug("TC: updated configuration %o, %o", this.settings, this.initSettings);
  }
  tryCreateRemoveRegex(param) {
    return param ? new RegExp(param, "g") : null;
  }
  tryCreateResetRegex(param) {
    return param ? new RegExp(param + "( \\^[A-Za-z0-9-]+)?$") : null;
  }
  tryCreateCompleteRegex(param) {
    return new RegExp(`^([\\s>]*- \\[)[${param}](\\] .*)$`);
  }
  tryCreateIncompleteRegex(param) {
    return new RegExp(`^([\\s>]*- \\[)[${param}](\\] .*)$`);
  }
  removeCheckboxFromLine(lineText) {
    return lineText.replace(this.stripTask, "$1 $2");
  }
  completeTaskLine(lineText, mark) {
    let marked = lineText.replace(this.initSettings.incompleteTaskRegExp, "$1" + mark + "$2");
    if (this.initSettings.removeRegExp) {
      marked = marked.replace(this.initSettings.removeRegExp, "");
    }
    if (this.settings.appendDateFormat) {
      const strictLineEnding = lineText.endsWith("  ");
      let blockid = "";
      const match = this.blockRef.exec(marked);
      if (match && match[2]) {
        marked = match[1];
        blockid = match[2];
      }
      if (!marked.endsWith(" ")) {
        marked += " ";
      }
      marked += (0, import_obsidian.moment)().format(this.settings.appendDateFormat) + blockid;
      if (strictLineEnding) {
        marked += "  ";
      }
    }
    return marked;
  }
  completeEditorLineTask(editor, mark, i) {
    const lineText = editor.getLine(i);
    const incompleteTask = this.initSettings.incompleteTaskRegExp.exec(lineText);
    if (incompleteTask) {
      const marked = this.completeTaskLine(lineText, mark);
      editor.setLine(i, marked);
    }
  }
  markAllTasksComplete(source, mark) {
    const lines = source.split("\n");
    const result = [];
    for (const line of lines) {
      if (this.initSettings.incompleteTaskRegExp.exec(line)) {
        result.push(this.completeTaskLine(line, mark));
      } else {
        result.push(line);
      }
    }
    return result.join("\n");
  }
  markTaskInSource(source, mark, lines = []) {
    const split = source.split("\n");
    for (const n of lines) {
      if (!this.anyTaskMark.test(split[n])) {
        const match = this.anyListItem.exec(split[n]);
        if (match && match[2]) {
          console.debug("TC: list item, convert to a task %s", split[n]);
          split[n] = match[1] + "[ ] " + match[2];
        } else {
          console.debug("TC: not a task or list item %s", split[n]);
          continue;
        }
      }
      if (this.initSettings.completedTasks.indexOf(mark) >= 0) {
        if (this.isIncompleteTaskLine(split[n])) {
          console.debug("TC: complete task with %s: %s", mark, split[n]);
          split[n] = this.completeTaskLine(split[n], mark);
        } else {
          console.debug("TC: task already completed (%s): %s", mark, split[n]);
        }
      } else if (this.settings.incompleteTaskValues.indexOf(mark) >= 0) {
        console.debug("TC: reset task with %s: %s", mark, split[n]);
        split[n] = this.resetTaskLine(split[n], mark);
      } else if (mark === "Backspace") {
        split[n] = this.removeCheckboxFromLine(split[n]);
      } else {
        console.debug("TC: unrecognized mark %s, check configuration settings", mark);
      }
    }
    return split.join("\n");
  }
  resetTaskLine(lineText, mark = " ") {
    let marked = lineText.replace(this.anyTaskMark, "$1" + mark + "$2");
    const strictLineEnding = lineText.endsWith("  ");
    let blockid = "";
    const match = this.blockRef.exec(marked);
    if (match && match[2]) {
      marked = match[1];
      blockid = match[2];
    }
    if (this.initSettings.resetRegExp) {
      marked = marked.replace(this.initSettings.resetRegExp, "");
    }
    marked = marked.replace(/\s*$/, blockid);
    if (strictLineEnding) {
      marked += "  ";
    }
    return marked;
  }
  resetTaskOnLine(editor, i, mark) {
    const lineText = editor.getLine(i);
    const marked = this.resetTaskLine(lineText, mark);
    editor.setLine(i, marked);
  }
  resetAllTasks(source) {
    const LOG_HEADING = this.settings.completedAreaHeader || "## Log";
    const lines = source.split("\n");
    const result = [];
    let inCompletedSection = false;
    for (const line of lines) {
      if (inCompletedSection) {
        if (line.startsWith("#") || line.trim() === "---") {
          inCompletedSection = false;
        }
        result.push(line);
      } else if (line.trim() === LOG_HEADING) {
        inCompletedSection = true;
        result.push(line);
      } else if (this.isCompletedTaskLine(line)) {
        result.push(this.resetTaskLine(line));
      } else {
        result.push(line);
      }
    }
    return result.join("\n");
  }
  moveCompletedTasksInFile(source) {
    const LOG_HEADING = this.settings.completedAreaHeader || "## Log";
    const lines = source.split("\n");
    if (source.indexOf(LOG_HEADING) < 0) {
      if (lines[lines.length - 1].trim() !== "") {
        lines.push("");
      }
      lines.push(LOG_HEADING);
    }
    const remaining = [];
    const completedSection = [];
    const newTasks = [];
    let inCompletedSection = false;
    let inTask = false;
    let inCallout = false;
    let completedItemsIndex = lines.length;
    for (let line of lines) {
      if (inCompletedSection) {
        if (line.startsWith("#") || line.trim() === "---") {
          inCompletedSection = false;
          remaining.push(line);
        } else {
          completedSection.push(line);
        }
      } else if (line.trim() === LOG_HEADING) {
        inCompletedSection = true;
        completedItemsIndex = remaining.push(line);
        remaining.push("%%%COMPLETED_ITEMS_GO_HERE%%%");
      } else {
        if (this.isCompletedTaskLine(line)) {
          if (this.settings.completedAreaRemoveCheckbox) {
            line = this.removeCheckboxFromLine(line);
          }
          inTask = true;
          inCallout = this.isCallout(line);
          newTasks.push(line);
        } else if (inTask && !this.isTaskLine(line) && this.isContinuation(line, inCallout)) {
          newTasks.push(line);
        } else {
          inTask = false;
          inCallout = false;
          remaining.push(line);
        }
      }
    }
    let result = remaining.slice(0, completedItemsIndex).concat(...newTasks).concat(...completedSection);
    if (completedItemsIndex < remaining.length - 1) {
      result = result.concat(remaining.slice(completedItemsIndex + 1));
    }
    return result.join("\n");
  }
  isCompletedTaskLine(lineText) {
    return this.initSettings.completedTaskRegExp.test(lineText);
  }
  isIncompleteTaskLine(lineText) {
    return this.initSettings.incompleteTaskRegExp.test(lineText);
  }
  isTaskLine(lineText) {
    return this.anyTaskMark.test(lineText);
  }
  isContinuation(lineText, inCallout) {
    if (inCallout) {
      const match = this.blockQuote.exec(lineText);
      if (match) {
        return match[1].endsWith(">") || match[1].endsWith("  ") || match[1].endsWith("	");
      }
    }
    return this.continuation.test(lineText);
  }
  isCallout(lineText) {
    return this.blockQuote.test(lineText);
  }
};

// src/taskcollector-Settings.ts
var DEFAULT_SETTINGS = {
  completedAreaHeader: "## Log",
  removeExpression: "",
  appendDateFormat: "",
  incompleteTaskValues: " ",
  supportCanceledTasks: false,
  rightClickComplete: false,
  rightClickMark: false,
  rightClickMove: false,
  rightClickReset: false,
  rightClickResetTask: false,
  rightClickResetAll: false,
  rightClickToggleAll: false,
  completedAreaRemoveCheckbox: false,
  onlyLowercaseX: false
};

// src/taskcollector-SettingsTab.ts
var import_obsidian2 = __toModule(require("obsidian"));
var TaskCollectorSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin, taskCollector) {
    super(app, plugin);
    this.plugin = plugin;
    this.taskCollector = taskCollector;
  }
  display() {
    this.containerEl.empty();
    this.containerEl.createEl("h1", { text: "Task Collector" });
    const tempSettings = Object.assign(this.taskCollector.settings);
    new import_obsidian2.Setting(this.containerEl).setName("Only support x for completed tasks").setDesc("Only use 'x' (lower case) to indicate completed tasks.").addToggle((toggle) => toggle.setValue(tempSettings.onlyLowercaseX).onChange((value) => __async(this, null, function* () {
      tempSettings.onlyLowercaseX = value;
      this.taskCollector.updateSettings(tempSettings);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(this.containerEl).setName("Support canceled tasks").setDesc("Use a - to indicate canceled tasks. Canceled tasks are processed in the same way as completed tasks using options below.").addToggle((toggle) => toggle.setValue(tempSettings.supportCanceledTasks).onChange((value) => __async(this, null, function* () {
      tempSettings.supportCanceledTasks = value;
      this.taskCollector.updateSettings(tempSettings);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(this.containerEl).setName("Additional task types").setDesc("Specify the set of single characters that indicate in-progress or incomplete tasks, e.g. 'i> !?D'.").addText((text) => text.setPlaceholder("> !?").setValue(tempSettings.incompleteTaskValues).onChange((value) => __async(this, null, function* () {
      if (value.contains("x")) {
        console.log(`Set of characters should not contain the marker for completed tasks (x): ${value}`);
      } else if (!tempSettings.onlyLowercaseX && value.contains("X")) {
        console.log(`Set of characters should not contain the marker for canceled tasks (X): ${value}`);
      } else if (tempSettings.supportCanceledTasks && value.contains("-")) {
        console.log(`Set of characters should not contain the marker for canceled tasks (-): ${value}`);
      } else {
        if (!value.contains(" ")) {
          value = " " + value;
        }
        tempSettings.incompleteTaskValues = value;
        this.taskCollector.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }
    })));
    this.containerEl.createEl("h2", { text: "Completing tasks" });
    this.containerEl.createEl("p", {
      text: "Completed tasks, marked by 'x', 'X' (and optionally '-' for canceled items) gain special treatment based on the settings below."
    });
    new import_obsidian2.Setting(this.containerEl).setName("Append date to completed task").setDesc("If non-empty, append today's date in the given moment.js string format to the end of the task text.").addMomentFormat((momentFormat) => momentFormat.setPlaceholder("YYYY-MM-DD").setValue(tempSettings.appendDateFormat).onChange((value) => __async(this, null, function* () {
      try {
        (0, import_obsidian2.moment)().format(value);
        tempSettings.appendDateFormat = value;
        this.taskCollector.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      } catch (e) {
        console.log(`Error parsing specified date format: ${value}`);
      }
    })));
    new import_obsidian2.Setting(this.containerEl).setName("Remove text in completed task").setDesc("Text matching this regular expression should be removed from the task text. Be careful! Test your expression first. The global flag, 'g' is used for a per-line match.").addText((text) => text.setPlaceholder(" #(todo|task)").setValue(tempSettings.removeExpression).onChange((value) => __async(this, null, function* () {
      try {
        this.taskCollector.tryCreateRemoveRegex(value);
        tempSettings.removeExpression = value;
        this.taskCollector.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      } catch (e) {
        console.log(`Error parsing regular expression for text replacement: ${value}`);
      }
    })));
    this.containerEl.createEl("h2", { text: "Moving completed tasks" });
    new import_obsidian2.Setting(this.containerEl).setName("Completed area header").setDesc(`Completed (or canceled) items will be inserted under the specified header (most recent at the top). When scanning the document for completed/canceled tasks, the contents from this configured header to the next heading or separator (---) will be ignored. This heading will be created if the command is invoked and the heading does not exist. The default heading is '${DEFAULT_SETTINGS.completedAreaHeader}'.`).addText((text) => text.setPlaceholder("## Log").setValue(tempSettings.completedAreaHeader).onChange((value) => __async(this, null, function* () {
      tempSettings.completedAreaHeader = value.trim();
      this.taskCollector.updateSettings(tempSettings);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(this.containerEl).setName("Remove the checkbox from moved items").setDesc(`Remove the checkbox from completed (or canceled) tasks during the move to the completed area. This transforms tasks into normal list items. Task Collector will not be able to reset these items. They also will not appear in task searches or queries. The default value is: '${DEFAULT_SETTINGS.completedAreaRemoveCheckbox}'.`).addToggle((toggle) => toggle.setValue(tempSettings.completedAreaRemoveCheckbox).onChange((value) => __async(this, null, function* () {
      tempSettings.completedAreaRemoveCheckbox = value;
      this.taskCollector.updateSettings(tempSettings);
      yield this.plugin.saveSettings();
    })));
    this.containerEl.createEl("h2", { text: "Right-click Menu items" });
    this.containerEl.createEl("p", {
      text: "Task Collector creates commands that can be bound to hotkeys or accessed using slash commands for marking tasks complete (or canceled) and resetting tasks to an incomplete state. The following settings add right click context menu items for those commands."
    });
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for marking a task").setDesc("Add an item to the right-click menu in edit mode to mark the task _on the current line (or within the current selection)_. This menu item will trigger a quick pop-up modal to select the desired mark value. The selected value will determine follow-on actions: complete, cancel, or reset.").addToggle((toggle) => toggle.setValue(tempSettings.rightClickMark).onChange((value) => __async(this, null, function* () {
      tempSettings.rightClickMark = value;
      this.taskCollector.updateSettings(tempSettings);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for completing a task").setDesc("Add an item to the right-click menu in edit mode to mark the task _on the current line (or within the current selection)_ complete. If canceled items are supported, an additional menu item will be added to mark selected tasks as canceled.").addToggle((toggle) => toggle.setValue(tempSettings.rightClickComplete).onChange((value) => __async(this, null, function* () {
      tempSettings.rightClickComplete = value;
      this.taskCollector.updateSettings(tempSettings);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for resetting a task").setDesc("Add an item to the right-click menu in edit mode to reset the task _on the current line (or within the current selection)_.").addToggle((toggle) => toggle.setValue(tempSettings.rightClickResetTask).onChange((value) => __async(this, null, function* () {
      tempSettings.rightClickResetTask = value;
      this.taskCollector.updateSettings(tempSettings);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(this.containerEl).setName("Add menu items for completing all tasks").setDesc("Add an item to the right-click menu in edit mode to mark _all_ incomplete tasks in the current document complete.").addToggle((toggle) => toggle.setValue(tempSettings.rightClickToggleAll).onChange((value) => __async(this, null, function* () {
      tempSettings.rightClickToggleAll = value;
      this.taskCollector.updateSettings(tempSettings);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for resetting all tasks").setDesc("Add an item to the right-click menu to reset _all_ completed (or canceled) tasks.").addToggle((toggle) => toggle.setValue(tempSettings.rightClickResetAll).onChange((value) => __async(this, null, function* () {
      tempSettings.rightClickResetAll = value;
      this.taskCollector.updateSettings(tempSettings);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for moving all completed tasks").setDesc("Add an item to the right-click menu to move _all_ completed (or canceled) tasks.").addToggle((toggle) => toggle.setValue(tempSettings.rightClickMove).onChange((value) => __async(this, null, function* () {
      tempSettings.rightClickMove = value;
      this.taskCollector.updateSettings(tempSettings);
      yield this.plugin.saveSettings();
    })));
  }
};

// src/taskcollector-TaskMarkModal.ts
var import_obsidian3 = __toModule(require("obsidian"));
function getMark(app, taskCollector) {
  return new Promise((resolve) => {
    const modal = new TaskMarkModal(app, taskCollector);
    modal.onClose = () => {
      resolve(modal.chosenMark);
    };
    modal.open();
  });
}
var TaskMarkModal = class extends import_obsidian3.Modal {
  constructor(app, taskCollector) {
    super(app);
    this.taskCollector = taskCollector;
    this.containerEl.id = "taskcollector-modal";
  }
  onOpen() {
    const selector = this.contentEl.createDiv("taskcollector-selector markdown-preview-view");
    const completedTasks = (this.taskCollector.settings.onlyLowercaseX ? "x" : "xX") + (this.taskCollector.settings.supportCanceledTasks ? "-" : "");
    const completedList = selector.createEl("ul");
    completedList.addClass("contains-task-list");
    this.addTaskValues(completedList, completedTasks, true);
    const list = selector.createEl("ul");
    list.addClass("contains-task-list");
    this.addTaskValues(list, this.taskCollector.settings.incompleteTaskValues, false);
    const footer = selector.createEl("nav");
    const esc = footer.createSpan();
    esc.innerHTML = "<b>esc</b> to dismiss";
    const bksp = footer.createSpan();
    bksp.innerHTML = "<b>bksp</b> to remove <code>[]</code>";
    const self = this;
    const keyListener = function(event) {
      self.chosenMark = event.key;
      event.preventDefault();
      event.stopImmediatePropagation();
      self.close();
    };
    this.scope.register([], null, keyListener);
    this.scope.register(["Shift"], null, keyListener);
  }
  addTaskValues(list, choices, markComplete) {
    const self = this;
    for (const character of choices) {
      const li = list.createEl("li", {
        cls: "task-list-item " + (character == " " ? "" : " is-checked"),
        attr: {
          "data-task": character
        }
      });
      li.addEventListener("click", function(event) {
        self.chosenMark = character;
        self.close();
      });
      const input = li.createEl("input", {
        cls: "task-list-item-checkbox",
        attr: {
          id: "task-list-item-checkbox-" + character,
          type: "checkbox",
          style: "pointer-events: none;"
        }
      });
      if (character != " ") {
        input.setAttribute("checked", "");
      }
      li.createEl("span", {
        text: character == " " ? "\u2423" : character,
        attr: {
          style: "pointer-events: none;"
        }
      });
    }
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/taskcollector-Plugin.ts
var Icons;
(function(Icons2) {
  Icons2["COMPLETE"] = "tc-complete-item";
  Icons2["CANCEL"] = "tc-cancel-item";
  Icons2["RESET"] = "tc-reset-item";
  Icons2["MARK"] = "tc-mark-item";
  Icons2["COMPLETE_ALL"] = "tc-complete-all-items";
  Icons2["CLEAR"] = "tc-clear-all-items";
  Icons2["MOVE"] = "tc-move-all-checked-items";
})(Icons || (Icons = {}));
var TaskCollectorPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.handlersRegistered = false;
  }
  onload() {
    return __async(this, null, function* () {
      console.log("loading Task Collector (TC)");
      this.taskCollector = new TaskCollector(this.app);
      this.addSettingTab(new TaskCollectorSettingsTab(this.app, this, this.taskCollector));
      yield this.loadSettings();
      (0, import_obsidian4.addIcon)(Icons.COMPLETE, '<svg xmlns="http://www.w3.org/2000/svg" width="100px" height="100px" fill="currentColor" class="bi bi-check-square-fill" viewBox="0 0 16 16">  <path d="M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2zm10.03 4.97a.75.75 0 0 1 .011 1.05l-3.992 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.75.75 0 0 1 1.08-.022z"/></svg>');
      (0, import_obsidian4.addIcon)(Icons.CANCEL, '<svg xmlns="http://www.w3.org/2000/svg" width="100px" height="100px" fill="currentColor" class="bi bi-dash-square-fill" viewBox="0 0 16 16">  <path d="M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2zm2.5 7.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1z"/></svg>');
      (0, import_obsidian4.addIcon)(Icons.RESET, '<svg xmlns="http://www.w3.org/2000/svg" width="100px" height="100px" fill="currentColor" class="bi bi-square-fill" viewBox="0 0 16 16"><path d="M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2z"/></svg>');
      (0, import_obsidian4.addIcon)(Icons.MARK, '<svg class="bi bi-square-fill" width="100px" height="100px" fill="currentColor" version="1.1" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path transform="scale(.16)" d="m12.5 0a12.5 12.5 0 00-12.5 12.5v75a12.5 12.5 0 0012.5 12.5h75a12.5 12.5 0 0012.5-12.5v-75a12.5 12.5 0 00-12.5-12.5h-75zm38.146 21.135 8.7324 19.098 20.684 3.6328-15.465 14.207 2.9355 20.793-18.289-10.316-18.869 9.2188 4.1602-20.584-14.598-15.098 20.861-2.4043 9.8477-18.547z" stroke-width="6.25"/></svg>');
      (0, import_obsidian4.addIcon)(Icons.COMPLETE_ALL, '<svg class="bi bi-square-fill" fill="currentColor" version="1.1" width="100px" height="100px" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="m2 0a2 2 0 00-2 2v12a2 2 0 002 2h12a2 2 0 002-2v-12a2 2 0 00-2-2h-12zm1.5098 2.041h1.5a1.5 1.5 0 011.5 1.5v1.5a1.5 1.5 0 01-1.5 1.5h-1.5a1.5 1.5 0 01-1.5-1.5v-1.5a1.5 1.5 0 011.5-1.5zm4.3945 1.2207h5.6895a.40645.5 0 01.40625.5v1a.40645.5 0 01-.40625.5h-5.6895a.40645.5 0 01-.40625-.5v-1a.40645.5 0 01.40625-.5zm-4.4023 6.2656h1.5a1.5 1.5 0 011.5 1.5v1.5a1.5 1.5 0 01-1.5 1.5h-1.5a1.5 1.5 0 01-1.5-1.5v-1.5a1.5 1.5 0 011.5-1.5zm4.4023 1.2656h5.6895a.40645.5 0 01.40625.5v1a.40645.5 0 01-.40625.5h-5.6895a.40645.5 0 01-.40625-.5v-1a.40645.5 0 01.40625-.5z"/><g transform="translate(.49737 -.0026315)" fill="currentColor"><path d="m3.6171 13.149a.5.5 0 01-.708 0l-1-1a.50063.50063 0 01.708-.708l.646.647 1.646-1.647a.50063.50063 0 01.708.708z"/><path d="m3.6171 5.6181a.5.5 0 01-.708 0l-1-1a.50063.50063 0 11.708-.708l.646.647 1.646-1.647a.50063.50063 0 11.708.708z"/></g></svg>');
      (0, import_obsidian4.addIcon)(Icons.CLEAR, '<svg class="bi bi-square-fill" fill="currentColor" version="1.1" width="100px" height="100px" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="m2 0a2 2 0 00-2 2v12a2 2 0 002 2h12a2 2 0 002-2v-12a2 2 0 00-2-2h-12zm1.5098 2.041h1.5a1.5 1.5 0 011.5 1.5v1.5a1.5 1.5 0 01-1.5 1.5h-1.5a1.5 1.5 0 01-1.5-1.5v-1.5a1.5 1.5 0 011.5-1.5zm4.3945 1.2207h5.6895a.40645.5 0 01.40625.5v1a.40645.5 0 01-.40625.5h-5.6895a.40645.5 0 01-.40625-.5v-1a.40645.5 0 01.40625-.5zm-4.4023 6.2656h1.5a1.5 1.5 0 011.5 1.5v1.5a1.5 1.5 0 01-1.5 1.5h-1.5a1.5 1.5 0 01-1.5-1.5v-1.5a1.5 1.5 0 011.5-1.5zm4.4023 1.2656h5.6895a.40645.5 0 01.40625.5v1a.40645.5 0 01-.40625.5h-5.6895a.40645.5 0 01-.40625-.5v-1a.40645.5 0 01.40625-.5z"/></svg>');
      (0, import_obsidian4.addIcon)(Icons.MOVE, '<svg xmlns="http://www.w3.org/2000/svg" width="100px" height="100px" fill="currentColor" class="bi bi-save-fill" viewBox="0 0 16 16">  <path d="M8.5 1.5A1.5 1.5 0 0 1 10 0h4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h6c-.314.418-.5.937-.5 1.5v7.793L4.854 6.646a.5.5 0 1 0-.708.708l3.5 3.5a.5.5 0 0 0 .708 0l3.5-3.5a.5.5 0 0 0-.708-.708L8.5 9.293V1.5z"/></svg>');
      const completeTaskCommand = {
        id: "task-collector-mark-done",
        name: "Complete item",
        icon: Icons.COMPLETE,
        editorCallback: (editor, view) => {
          this.markTaskOnLines("x", this.getCurrentLinesFromEditor(editor));
        }
      };
      const cancelTaskCommand = {
        id: "task-collector-mark-canceled",
        name: "Cancel item",
        icon: Icons.CANCEL,
        editorCallback: (editor, view) => {
          this.markTaskOnLines("-", this.getCurrentLinesFromEditor(editor));
        }
      };
      const resetTaskCommand = {
        id: "task-collector-mark-reset",
        name: "Reset item",
        icon: Icons.RESET,
        editorCallback: (editor, view) => {
          this.markTaskOnLines(" ", this.getCurrentLinesFromEditor(editor));
        }
      };
      const markTaskCommand = {
        id: "task-collector-mark",
        name: "Mark item",
        icon: Icons.MARK,
        editorCallback: (editor, view) => __async(this, null, function* () {
          const mark = yield getMark(this.app, this.taskCollector);
          if (mark) {
            this.markTaskOnLines(mark, this.getCurrentLinesFromEditor(editor));
          }
        })
      };
      const completeAllTasksCommand = {
        id: "task-collector-mark-all-done",
        name: "Complete all tasks",
        icon: Icons.COMPLETE_ALL,
        callback: () => __async(this, null, function* () {
          this.completeAllTasks();
        })
      };
      const clearAllTasksCommand = {
        id: "task-collector-clear-all-items",
        name: "Reset all completed tasks",
        icon: Icons.CLEAR,
        callback: () => __async(this, null, function* () {
          this.resetAllTasks();
        })
      };
      const moveTaskCommand = {
        id: "task-collector-move-completed-tasks",
        name: "Move all completed tasks to configured heading",
        icon: Icons.MOVE,
        callback: () => __async(this, null, function* () {
          this.moveAllTasks();
        })
      };
      this.addCommand(completeTaskCommand);
      if (this.taskCollector.settings.supportCanceledTasks) {
        this.addCommand(cancelTaskCommand);
      }
      this.addCommand(markTaskCommand);
      this.addCommand(resetTaskCommand);
      this.addCommand(moveTaskCommand);
      this.addCommand(completeAllTasksCommand);
      this.addCommand(clearAllTasksCommand);
      this.registerHandlers();
    });
  }
  getCurrentLinesFromEditor(editor) {
    const lines = [];
    if (editor.somethingSelected()) {
      const cursorStart = editor.getCursor("from");
      const cursorEnd = editor.getCursor("to");
      for (let i = cursorStart.line; i <= cursorEnd.line; i++) {
        lines.push(i);
      }
    } else {
      const anchor = editor.getCursor("from");
      lines.push(anchor.line);
    }
    return lines;
  }
  buildMenu(menu, lines) {
    if (this.taskCollector.settings.rightClickMark) {
      menu.addItem((item) => item.setTitle("(TC) Mark Task").setIcon(Icons.MARK).onClick(() => __async(this, null, function* () {
        const mark = yield getMark(this.app, this.taskCollector);
        if (mark) {
          this.markTaskOnLines(mark, lines);
        }
      })));
    }
    if (this.taskCollector.settings.rightClickComplete) {
      menu.addItem((item) => item.setTitle("(TC) Complete Task").setIcon(Icons.COMPLETE).onClick(() => {
        this.markTaskOnLines("x", lines);
      }));
      if (this.taskCollector.settings.supportCanceledTasks) {
        menu.addItem((item) => item.setTitle("(TC) Cancel Task").setIcon(Icons.CANCEL).onClick(() => {
          this.markTaskOnLines("-", lines);
        }));
      }
    }
    if (this.taskCollector.settings.rightClickResetTask) {
      menu.addItem((item) => item.setTitle("(TC) Reset Task").setIcon(Icons.RESET).onClick(() => {
        this.markTaskOnLines(" ", lines);
      }));
    }
    if (this.taskCollector.settings.rightClickMove) {
      menu.addItem((item) => item.setTitle("(TC) Move completed tasks").setIcon(Icons.MOVE).onClick(() => __async(this, null, function* () {
        this.moveAllTasks();
      })));
    }
    if (this.taskCollector.settings.rightClickToggleAll) {
      menu.addItem((item) => item.setTitle("(TC) Complete All Tasks").setIcon(Icons.COMPLETE_ALL).onClick(() => __async(this, null, function* () {
        this.completeAllTasks();
      })));
    }
    if (this.taskCollector.settings.rightClickResetAll) {
      menu.addItem((item) => item.setTitle("(TC) Reset All Tasks").setIcon(Icons.CLEAR).onClick(() => __async(this, null, function* () {
        this.resetAllTasks();
      })));
    }
  }
  markTaskOnLines(mark, lines) {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const result = this.taskCollector.markTaskInSource(source, mark, lines);
      this.app.vault.modify(activeFile, result);
    });
  }
  moveAllTasks() {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const result = this.taskCollector.moveCompletedTasksInFile(source);
      this.app.vault.modify(activeFile, result);
    });
  }
  completeAllTasks() {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const result = this.taskCollector.markAllTasksComplete(source, "x");
      this.app.vault.modify(activeFile, result);
    });
  }
  resetAllTasks() {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const result = this.taskCollector.resetAllTasks(source);
      this.app.vault.modify(activeFile, result);
    });
  }
  registerHandlers() {
    if (this.taskCollector.initSettings.rightClickTaskMenu && !this.handlersRegistered) {
      this.handlersRegistered = true;
      this.registerEvent(this.eventRef = this.app.workspace.on("editor-menu", (menu, editor) => {
        this.buildMenu(menu, this.getCurrentLinesFromEditor(editor));
      }));
      this.registerMarkdownPostProcessor(this.postProcessor = (el, ctx) => {
        const checkboxes = el.querySelectorAll(".task-list-item-checkbox");
        if (!checkboxes.length)
          return;
        const section = ctx.getSectionInfo(el);
        if (!section)
          return;
        const { lineStart } = section;
        for (const checkbox of Array.from(checkboxes)) {
          const line = Number(checkbox.dataset.line);
          this.registerDomEvent(checkbox.parentElement, "contextmenu", (ev) => {
            ev.preventDefault();
            const view = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
            if (view && view.editor) {
              const menu = new import_obsidian4.Menu(this.app);
              this.buildMenu(menu, [lineStart + line]);
              menu.showAtMouseEvent(ev);
            }
          });
        }
      });
    }
  }
  unregisterHandlers() {
    this.handlersRegistered = false;
    this.app.workspace.offref(this.eventRef);
    this.eventRef = null;
    import_obsidian4.MarkdownPreviewRenderer.unregisterPostProcessor(this.postProcessor);
  }
  onunload() {
    console.log("unloading Task Collector");
  }
  loadSettings() {
    return __async(this, null, function* () {
      const settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
      this.taskCollector.updateSettings(settings);
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.taskCollector.settings);
      if (this.taskCollector.initSettings.rightClickTaskMenu && !this.handlersRegistered) {
        this.registerHandlers();
      }
      if (!this.taskCollector.initSettings.rightClickTaskMenu && this.handlersRegistered) {
        this.unregisterHandlers();
      }
    });
  }
};

// src/main.ts
var main_default = TaskCollectorPlugin;
